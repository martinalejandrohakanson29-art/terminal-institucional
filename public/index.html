<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Institucional BTC/USDT Nivel Dios</title>
    
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    
    <style>
        body { margin: 0; padding: 0; background-color: #131722; color: white; font-family: Arial, sans-serif; overflow: hidden; }
        #header { padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; background-color: #1e222d; border-bottom: 1px solid #2B2B43; height: 40px; }
        h2 { margin: 0; font-size: 1.2rem; }
        
        .botonera { display: flex; gap: 5px; align-items: center; }
        .btn-tiempo { background-color: #2B2B43; color: #d1d4dc; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        .btn-tiempo:hover { background-color: #3f3f5a; }
        .btn-activo { background-color: #2962FF; color: white; }

        #main-content { display: flex; width: 100vw; height: calc(100vh - 60px); }
        #chart-container { flex-grow: 1; position: relative; } 

        #orderbook-container {
            width: 300px; 
            background-color: #1e222d;
            border-left: 1px solid #2B2B43;
            display: flex;
            flex-direction: column;
            font-size: 13px;
            overflow-y: auto;
        }
        
        .ob-titulo { text-align: center; padding: 12px 10px 5px; font-weight: bold; font-size: 15px; background-color: #131722; color: #d1d4dc;}
        .ob-subtitulo { text-align: center; font-size: 11px; color: #848e9c; padding-bottom: 10px; border-bottom: 1px solid #2B2B43; background-color: #131722; display: flex; justify-content: center; align-items: center; gap: 5px;}
        
        .input-rango {
            background-color: #2B2B43; color: #FFD700; border: 1px solid #3f3f5a; border-radius: 4px; width: 45px; text-align: center; font-weight: bold; font-size: 11px; padding: 2px; outline: none;
        }
        
        .seccion-panel { padding: 10px; border-bottom: 1px solid #2B2B43; }
        .titulo-rojo { color: #ef5350; font-weight: bold; margin-bottom: 8px; text-align: center; }
        .titulo-verde { color: #26a69a; font-weight: bold; margin-bottom: 8px; text-align: center; }
        
        .muro-item { display: flex; justify-content: space-between; background-color: #131722; padding: 6px 10px; margin-bottom: 4px; border-radius: 4px; font-family: monospace; align-items: center; }
        .muro-precio { font-weight: bold; font-size: 13px; }
        .muro-volumen { color: #d1d4dc; font-size: 13px; }

        @keyframes destello { 0% { background-color: rgba(255, 215, 0, 0.5); } 100% { background-color: #131722; } }
        .flash-trade { animation: destello 1s ease-out; }
    </style>
</head>
<body>

    <div id="header">
        <h2>Terminal Institucional BTC/USDT</h2>
        
        <div class="botonera" style="margin-right: auto; margin-left: 20px;">
            <span style="font-size: 12px; color: #848e9c; margin-right: 5px;">Filtrar marcadores (BTC): ></span>
            <input type="number" id="filtro-grafico" class="input-rango" value="5" min="1" step="1">
        </div>

        <div class="botonera">
            <button class="btn-tiempo btn-activo" id="btn-1m" onclick="cambiarTemporalidad('1m')">1m</button>
            <button class="btn-tiempo" id="btn-5m" onclick="cambiarTemporalidad('5m')">5m</button>
            <button class="btn-tiempo" id="btn-15m" onclick="cambiarTemporalidad('15m')">15m</button>
            <button class="btn-tiempo" id="btn-1h" onclick="cambiarTemporalidad('1h')">1H</button>
            <button class="btn-tiempo" id="btn-4h" onclick="cambiarTemporalidad('4h')">4H</button>
            <button class="btn-tiempo" id="btn-1d" onclick="cambiarTemporalidad('1d')">1D</button>
        </div>
    </div>
    
    <div id="main-content">
        <div id="chart-container"></div>
        <div id="orderbook-container">
            <div class="ob-titulo">TOP 3 MUROS (INTENCIÓN)</div>
            <div class="ob-subtitulo">Rango: <input type="number" id="input-rango" class="input-rango" value="2" min="1" max="10">% | Agrupado: $50</div>
            
            <div class="seccion-panel">
                <div class="titulo-rojo">RESISTENCIAS (Ventas)</div>
                <div id="top-ventas">Cargando radar...</div>
            </div>
            
            <div class="seccion-panel">
                <div class="titulo-verde">SOPORTES (Compras)</div>
                <div id="top-compras">Cargando radar...</div>
            </div>

            <div class="seccion-panel" style="border-bottom: none;">
                <div class="ob-titulo" style="padding-top: 5px;">CINTA EN VIVO (ACCIÓN)</div>
                <div class="ob-subtitulo">Filtro: > 1.0 BTC (Francotiradores)</div>
                <div id="whale-tape">Esperando órdenes gigantes...</div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. GRÁFICO (Velas, Delta, Open Interest) ---
        const container = document.getElementById('chart-container');
        const chartOptions = { width: container.clientWidth, height: container.clientHeight, layout: { textColor: '#d1d4dc', background: { type: 'solid', color: '#131722' } }, grid: { vertLines: { color: '#2B2B43' }, horzLines: { color: '#2B2B43' } }, crosshair: { mode: LightweightCharts.CrosshairMode.Normal }, rightPriceScale: { borderColor: '#2B2B43' }, timeScale: { borderColor: '#2B2B43', timeVisible: true, secondsVisible: false }, };
        const chart = LightweightCharts.createChart(container, chartOptions);
        
        const candlestickSeries = chart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
        const deltaSeries = chart.addHistogramSeries({ base: 0, priceScaleId: 'deltaScale' });
        chart.priceScale('deltaScale').applyOptions({ scaleMargins: { top: 0.65, bottom: 0.2 } });
        const oiSeries = chart.addAreaSeries({ lineColor: '#FFD700', topColor: 'rgba(255, 215, 0, 0.3)', bottomColor: 'rgba(255, 215, 0, 0.0)', lineWidth: 2, priceScaleId: 'oiScale', title: 'Open Int.' });
        chart.priceScale('oiScale').applyOptions({ scaleMargins: { top: 0.85, bottom: 0 } });

        window.addEventListener('resize', () => { chart.resize(container.clientWidth, container.clientHeight); });

        let binanceSocket = null; 
        let ultimoTiempoVela = null; 

        function cargarDatos(temporalidad) {
            if (binanceSocket !== null) binanceSocket.close();
            fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${temporalidad}&limit=1000`)
                .then(r => r.json())
                .then(datos => {
                    let velas = []; let datosDelta = [];
                    datos.forEach(v => {
                        let tiempo = Math.floor(v[0] / 1000); let apertura = parseFloat(v[1]); let cierre = parseFloat(v[4]);
                        let comprasMercado = parseFloat(v[9]); let ventasMercado = parseFloat(v[5]) - comprasMercado; let valorDelta = comprasMercado - ventasMercado;
                        velas.push({ time: tiempo, open: apertura, high: parseFloat(v[2]), low: parseFloat(v[3]), close: cierre });
                        datosDelta.push({ time: tiempo, value: valorDelta, color: valorDelta >= 0 ? 'rgba(38, 166, 154, 0.8)' : 'rgba(239, 83, 80, 0.8)' });
                        ultimoTiempoVela = tiempo; 
                    });
                    candlestickSeries.setData(velas); deltaSeries.setData(datosDelta); chart.timeScale().fitContent(); 

                    binanceSocket = new WebSocket(`wss://stream.binance.com:9443/ws/btcusdt@kline_${temporalidad}`);
                    binanceSocket.onmessage = function (e) {
                        const k = JSON.parse(e.data).k; let tiempo = Math.floor(k.t / 1000); let apertura = parseFloat(k.o); let cierre = parseFloat(k.c);
                        let comprasMercado = parseFloat(k.V); let ventasMercado = parseFloat(k.v) - comprasMercado; let valorDelta = comprasMercado - ventasMercado;
                        candlestickSeries.update({ time: tiempo, open: apertura, high: parseFloat(k.h), low: parseFloat(k.l), close: cierre });
                        deltaSeries.update({ time: tiempo, value: valorDelta, color: valorDelta >= 0 ? 'rgba(38, 166, 154, 0.8)' : 'rgba(239, 83, 80, 0.8)' });
                        ultimoTiempoVela = tiempo; 
                    };
                });
        }

        function cambiarTemporalidad(t) {
            document.querySelectorAll('.btn-tiempo').forEach(btn => btn.classList.remove('btn-activo'));
            document.getElementById(`btn-${t}`).classList.add('btn-activo'); cargarDatos(t);
        }
        cargarDatos('1m');


        // --- NUEVO: SISTEMA DE DIBUJADO DE BALLENAS (MARCADORES) ---
        let memoriaBallenasBD = []; // Guardamos aquí lo que responde el servidor

        function pedirHistorialBallenas() {
            // Le pedimos a nuestro propio servidor (Railway) los datos
            fetch('/api/ballenas')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    memoriaBallenasBD = datos;
                    dibujarMarcadores(); // Los dibujamos apenas llegan
                })
                .catch(err => console.error("Error al pedir historial:", err));
        }

        function dibujarMarcadores() {
            // Leemos el valor que pusiste en el input de arriba
            const limiteBtc = parseFloat(document.getElementById('filtro-grafico').value) || 5;
            
            let marcadores = [];
            let tiempoAntiChoque = {}; // Sistema de seguridad por si hay dos compras en el mismo milisegundo

            memoriaBallenasBD.forEach(trade => {
                const cantidadBtc = parseFloat(trade.cantidad);
                
                // SOLO procesamos si la cantidad es mayor o igual a tu filtro
                if (cantidadBtc >= limiteBtc) {
                    let tiempoSegundos = Math.floor(trade.tiempo_segundos);
                    
                    // Si ya existe un marcador en ese segundo exacto, lo movemos 1 segundo adelante
                    while(tiempoAntiChoque[tiempoSegundos]) {
                        tiempoSegundos += 1;
                    }
                    tiempoAntiChoque[tiempoSegundos] = true;

                    // Si vendió, la flecha va arriba (roja). Si compró, abajo (verde).
                    marcadores.push({
                        time: tiempoSegundos,
                        position: trade.es_venta ? 'aboveBar' : 'belowBar',
                        color: trade.es_venta ? '#ef5350' : '#26a69a',
                        shape: trade.es_venta ? 'arrowDown' : 'arrowUp',
                        text: `${cantidadBtc.toFixed(1)} BTC`,
                        size: cantidadBtc > 15 ? 2 : 1 // Las órdenes de más de 15 BTC se dibujan extra grandes
                    });
                }
            });

            // Requisito técnico obligatorio de la librería gráfica: los marcadores deben ordenarse de más viejo a más nuevo
            marcadores.sort((a, b) => a.time - b.time);
            
            // Los plasmamos sobre las velas
            candlestickSeries.setMarkers(marcadores);
        }

        // Cada vez que cambies el número en el input, redibujamos al instante
        document.getElementById('filtro-grafico').addEventListener('change', dibujarMarcadores);

        // Pedimos los datos 2 segundos después de abrir la página para dejar que el gráfico cargue primero
        setTimeout(pedirHistorialBallenas, 2000);
        // Actualizamos las flechas nuevas pidiéndole al servidor cada 30 segundos
        setInterval(pedirHistorialBallenas, 30000);


        // --- 2. SISTEMA PROFESIONAL DE MUROS LOCALES ---
        let orderBookLocal = { asks: {}, bids: {} };
        const TAMAÑO_GRUPO = 50; 
        let lineasDibujadas = []; 

        fetch('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=1000')
            .then(r => r.json())
            .then(datos => {
                datos.asks.forEach(a => orderBookLocal.asks[parseFloat(a[0])] = parseFloat(a[1]));
                datos.bids.forEach(b => orderBookLocal.bids[parseFloat(b[0])] = parseFloat(b[1]));
                iniciarActualizacionMurosEnVivo();
            });

        function iniciarActualizacionMurosEnVivo() {
            const depthSocket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@depth@1000ms');
            depthSocket.onmessage = function(e) {
                const cambios = JSON.parse(e.data);
                cambios.a.forEach(ask => {
                    let precio = parseFloat(ask[0]); let cantidad = parseFloat(ask[1]);
                    if (cantidad === 0) delete orderBookLocal.asks[precio];
                    else orderBookLocal.asks[precio] = cantidad;
                });
                cambios.b.forEach(bid => {
                    let precio = parseFloat(bid[0]); let cantidad = parseFloat(bid[1]);
                    if (cantidad === 0) delete orderBookLocal.bids[precio];
                    else orderBookLocal.bids[precio] = cantidad;
                });
            };
        }

        function agruparDiccionario(diccionario) {
            let agrupado = {};
            for (let precioStr in diccionario) {
                let precio = parseFloat(precioStr); let cantidad = diccionario[precioStr];
                let precioAgrupado = Math.floor(precio / TAMAÑO_GRUPO) * TAMAÑO_GRUPO;
                if (!agrupado[precioAgrupado]) agrupado[precioAgrupado] = 0;
                agrupado[precioAgrupado] += cantidad;
            }
            return Object.keys(agrupado).map(p => [parseFloat(p), agrupado[p]]);
        }

        function dibujarMuros() {
            let preciosVentas = Object.keys(orderBookLocal.asks).map(parseFloat).sort((a,b) => a - b);
            let preciosCompras = Object.keys(orderBookLocal.bids).map(parseFloat).sort((a,b) => b - a);
            if (preciosVentas.length === 0 || preciosCompras.length === 0) return; 

            let precioActual = (preciosVentas[0] + preciosCompras[0]) / 2;
            let porcentajeInput = parseFloat(document.getElementById('input-rango').value);
            if (isNaN(porcentajeInput) || porcentajeInput <= 0) porcentajeInput = 2; 
            
            let factorArriba = 1 + (porcentajeInput / 100); let factorAbajo = 1 - (porcentajeInput / 100);  

            let ventasAgrupadas = agruparDiccionario(orderBookLocal.asks);
            let comprasAgrupadas = agruparDiccionario(orderBookLocal.bids);

            let ventasEnRango = ventasAgrupadas.filter(v => v[0] <= precioActual * factorArriba).sort((a, b) => b[1] - a[1]);
            let comprasEnRango = comprasAgrupadas.filter(c => c[0] >= precioActual * factorAbajo).sort((a, b) => b[1] - a[1]);
            
            let top3Ventas = ventasEnRango.slice(0, 3); let top3Compras = comprasEnRango.slice(0, 3);

            document.getElementById('top-ventas').innerHTML = top3Ventas.map(v => `<div class="muro-item"><span class="muro-precio" style="color:#ef5350;">$${v[0].toFixed(2)}</span> <span class="muro-volumen">${v[1].toFixed(2)} BTC</span></div>`).join('');
            document.getElementById('top-compras').innerHTML = top3Compras.map(c => `<div class="muro-item"><span class="muro-precio" style="color:#26a69a;">$${c[0].toFixed(2)}</span> <span class="muro-volumen">${c[1].toFixed(2)} BTC</span></div>`).join('');

            lineasDibujadas.forEach(linea => candlestickSeries.removePriceLine(linea)); lineasDibujadas = []; 
            top3Ventas.forEach(v => lineasDibujadas.push(candlestickSeries.createPriceLine({ price: v[0], color: '#ef5350', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: `RES ${v[1].toFixed(0)} BTC` })));
            top3Compras.forEach(c => lineasDibujadas.push(candlestickSeries.createPriceLine({ price: c[0], color: '#26a69a', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: `SOP ${c[1].toFixed(0)} BTC` })));
        }

        setInterval(dibujarMuros, 2000);
        document.getElementById('input-rango').addEventListener('change', dibujarMuros);

        // --- 3. CINTA DE BALLENAS (aggTrade) ---
        const tapeSocket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@aggTrade');
        const UMBRAL_BTC = 1.0; let ultimosTrades = []; 

        tapeSocket.onmessage = function(evento) {
            const data = JSON.parse(evento.data); const cantidad = parseFloat(data.q); const precio = parseFloat(data.p); const agresorFueVendedor = data.m; 
            if (cantidad >= UMBRAL_BTC) {
                ultimosTrades.unshift({ precio: precio, cantidad: cantidad, esVenta: agresorFueVendedor });
                if (ultimosTrades.length > 5) ultimosTrades.pop(); 
                let htmlCinta = '';
                ultimosTrades.forEach((trade, indice) => {
                    let color = trade.esVenta ? '#ef5350' : '#26a69a'; let claseFlash = indice === 0 ? 'flash-trade' : '';
                    htmlCinta += `<div class="muro-item ${claseFlash}"><span class="muro-precio" style="color:${color};">$${trade.precio.toFixed(2)}</span><span class="muro-volumen">${trade.cantidad.toFixed(2)} BTC</span></div>`;
                });
                document.getElementById('whale-tape').innerHTML = htmlCinta;
            }
        };

        // --- 4. INTERÉS ABIERTO ---
        function actualizarOpenInterest() {
            fetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=BTCUSDT')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    if (ultimoTiempoVela) {
                        let contratosAbiertos = parseFloat(datos.openInterest);
                        oiSeries.update({ time: ultimoTiempoVela, value: contratosAbiertos });
                    }
                })
                .catch(error => console.log("Error al traer Open Interest:", error));
        }
        actualizarOpenInterest(); setInterval(actualizarOpenInterest, 3000);

    </script>
</body>
</html>
