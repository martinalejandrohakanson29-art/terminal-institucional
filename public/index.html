<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Institucional BTC/USDT Nivel Dios</title>
    
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; background-color: #f0f2f5; color: #1e1e1e; font-family: Arial, sans-serif; overflow: hidden; width: 100vw; height: 100vh; }
        #header { padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; background-color: #ffffff; border-bottom: 1px solid #d1d4dc; height: 60px; }
        h2 { margin: 0; font-size: 1.2rem; }
        
        .botonera { display: flex; gap: 5px; align-items: center; }
        .btn-tiempo { background-color: #f0f2f5; color: #1e1e1e; border: 1px solid #d1d4dc; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        .btn-tiempo:hover { background-color: #e2e8f0; }
        .btn-activo { background-color: #2962FF; color: white; border-color: #2962FF; }

        #main-content { display: flex; width: 100%; height: calc(100vh - 60px); }
        
        #charts-column { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; background-color: #f0f2f5; }
        #chart-main { flex: 3; position: relative; border-bottom: 2px solid #d1d4dc; } 
        #chart-delta { flex: 1; position: relative; border-bottom: 2px solid #d1d4dc; } 
        #chart-oi { flex: 1; position: relative; } 

        #orderbook-container {
            width: 320px; min-width: 320px; flex-shrink: 0; background-color: #ffffff; border-left: 1px solid #d1d4dc; display: flex; flex-direction: column; font-size: 13px; overflow-y: auto;
        }
        
        .ob-titulo { text-align: center; padding: 12px 10px 5px; font-weight: bold; font-size: 15px; background-color: #ffffff; color: #1e1e1e;}
        .ob-subtitulo { text-align: center; font-size: 11px; color: #64748b; padding-bottom: 10px; border-bottom: 1px solid #d1d4dc; background-color: #ffffff; display: flex; justify-content: center; align-items: center; gap: 5px;}
        
        .input-rango { background-color: #ffffff; color: #1e1e1e; border: 1px solid #d1d4dc; border-radius: 4px; width: 45px; text-align: center; font-weight: bold; font-size: 11px; padding: 2px; outline: none; }
        
        .seccion-panel { padding: 10px; border-bottom: 1px solid #d1d4dc; }
        .titulo-rojo { color: #ef5350; font-weight: bold; margin-bottom: 8px; text-align: center; }
        .titulo-verde { color: #26a69a; font-weight: bold; margin-bottom: 8px; text-align: center; }
        
        .muro-item { display: flex; justify-content: space-between; background-color: #f8f9fa; border: 1px solid #e2e8f0; padding: 6px 10px; margin-bottom: 4px; border-radius: 4px; font-family: monospace; align-items: center; }
        .muro-precio { font-weight: bold; font-size: 13px; }
        .muro-volumen { color: #64748b; font-size: 13px; }

        @keyframes destello { 0% { background-color: rgba(41, 98, 255, 0.2); } 100% { background-color: #f8f9fa; } }
        .flash-trade { animation: destello 1s ease-out; }
    </style>
</head>
<body>

    <div id="header">
        <h2>Terminal Institucional BTC/USDT</h2>
        
        <div class="botonera" style="margin-right: auto; margin-left: 20px;">
            <span style="font-size: 12px; color: #64748b; margin-right: 5px;">Filtrar marcadores Gráfico (BTC): ></span>
            <input type="number" id="filtro-grafico" class="input-rango" value="5" min="1" step="1">
        </div>

        <div class="botonera">
            <button class="btn-tiempo btn-activo" id="btn-1m" onclick="cambiarTemporalidad('1m')">1m</button>
            <button class="btn-tiempo" id="btn-5m" onclick="cambiarTemporalidad('5m')">5m</button>
            <button class="btn-tiempo" id="btn-15m" onclick="cambiarTemporalidad('15m')">15m</button>
            <button class="btn-tiempo" id="btn-1h" onclick="cambiarTemporalidad('1h')">1H</button>
            <button class="btn-tiempo" id="btn-4h" onclick="cambiarTemporalidad('4h')">4H</button>
            <button class="btn-tiempo" id="btn-1d" onclick="cambiarTemporalidad('1d')">1D</button>
        </div>
    </div>
    
    <div id="main-content">
        <div id="charts-column">
            <div id="chart-main"></div>
            <div id="chart-delta"></div>
            <div id="chart-oi"></div>
        </div>

        <div id="orderbook-container">
            <div class="ob-titulo">TOP 3 MUROS (INTENCIÓN)</div>
            <div class="ob-subtitulo">Rango: <input type="number" id="input-rango" class="input-rango" value="2" min="1" max="10">% | Agrupado: $50</div>
            
            <div class="seccion-panel">
                <div class="titulo-rojo">RESISTENCIAS (Ventas)</div>
                <div id="top-ventas">Cargando radar...</div>
            </div>
            
            <div class="seccion-panel">
                <div class="titulo-verde">SOPORTES (Compras)</div>
                <div id="top-compras">Cargando radar...</div>
            </div>

            <div class="seccion-panel" style="border-bottom: none;">
                <div class="ob-titulo" style="padding-top: 5px;">CINTA EN VIVO (ACCIÓN)</div>
                
                <div class="ob-subtitulo" style="flex-direction: column; gap: 8px;">
                    <div>Ver en Cinta: > <input type="number" id="filtro-cinta" class="input-rango" value="1" min="0.1" step="0.5"> BTC</div>
                    <div>Guardar BD: > <input type="number" id="filtro-bd" class="input-rango" value="1" min="0.1" step="0.5" title="Actualiza el servidor"> BTC</div>
                </div>

                <div id="whale-tape">Esperando órdenes gigantes...</div>
            </div>
        </div>
    </div>

    <script>
        const inputFiltroGrafico = document.getElementById('filtro-grafico');
        const inputFiltroCinta = document.getElementById('filtro-cinta');

        if (localStorage.getItem('memoriaGrafico')) {
            inputFiltroGrafico.value = localStorage.getItem('memoriaGrafico');
        }
        if (localStorage.getItem('memoriaCinta')) {
            inputFiltroCinta.value = localStorage.getItem('memoriaCinta');
        }

        inputFiltroCinta.addEventListener('change', function() {
            localStorage.setItem('memoriaCinta', this.value);
        });

        const chartOptionsBase = { 
            layout: { textColor: '#1e1e1e', background: { type: 'solid', color: '#f0f2f5' } }, 
            grid: { vertLines: { visible: false }, horzLines: { visible: false } }, 
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal }, 
            rightPriceScale: { borderColor: '#d1d4dc' }, 
            timeScale: { borderColor: '#d1d4dc', timeVisible: true, secondsVisible: false }, 
        };

        const chartMain = LightweightCharts.createChart(document.getElementById('chart-main'), chartOptionsBase);
        const chartDelta = LightweightCharts.createChart(document.getElementById('chart-delta'), chartOptionsBase);
        const chartOI = LightweightCharts.createChart(document.getElementById('chart-oi'), chartOptionsBase);

        const candlestickSeries = chartMain.addCandlestickSeries({ 
            upColor: '#26a69a', downColor: '#ef5350', borderVisible: true, borderUpColor: '#000000', borderDownColor: '#000000', wickUpColor: '#000000', wickDownColor: '#000000', priceLineColor: '#000000', priceLineWidth: 1 
        });
        
        const deltaSeries = chartDelta.addHistogramSeries({ base: 0 }); 
        const oiSeries = chartOI.addAreaSeries({ lineColor: '#FFD700', topColor: 'rgba(255, 215, 0, 0.3)', bottomColor: 'rgba(255, 215, 0, 0.0)', lineWidth: 2, title: 'Open Int.' }); 

        // --- SOLUCIÓN 1: Sincronizar por Tiempo Exacto en lugar de Índices ---
        let graficoGuia = null;

        function syncTimeScale(sourceChart, targetCharts) {
            sourceChart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                // Evitamos bucles infinitos permitiendo que solo el gráfico que movemos guíe a los demás
                if (graficoGuia !== null && graficoGuia !== sourceChart) return;
                
                graficoGuia = sourceChart;
                
                if (timeRange) {
                    targetCharts.forEach(chart => {
                        chart.timeScale().setVisibleRange(timeRange);
                    });
                }
                
                // Liberamos el candado un instante después
                setTimeout(() => { graficoGuia = null; }, 50);
            });
        }

        syncTimeScale(chartMain, [chartDelta, chartOI]);
        syncTimeScale(chartDelta, [chartMain, chartOI]);
        syncTimeScale(chartOI, [chartMain, chartDelta]);

        window.addEventListener('resize', () => { 
            const mainRect = document.getElementById('chart-main').getBoundingClientRect();
            chartMain.resize(mainRect.width, mainRect.height);
            
            const deltaRect = document.getElementById('chart-delta').getBoundingClientRect();
            chartDelta.resize(deltaRect.width, deltaRect.height);
            
            const oiRect = document.getElementById('chart-oi').getBoundingClientRect();
            chartOI.resize(oiRect.width, oiRect.height);
        });
        setTimeout(() => window.dispatchEvent(new Event('resize')), 100);

        let binanceSocket = null; 
        let ultimoTiempoVela = null; 
        let tiemposVelasActivas = [];
        let multiplicadorTemporalidad = 60; 
        let temporalidadActual = '1m';

        // --- SOLUCIÓN 2: Auto-reconectar el WebSocket de las velas si Binance lo cierra ---
        function iniciarWebSocketVelas() {
            if (binanceSocket !== null) {
                binanceSocket.close();
            }

            binanceSocket = new WebSocket(`wss://stream.binance.com:9443/ws/btcusdt@kline_${temporalidadActual}`);
            
            binanceSocket.onmessage = function (e) {
                const k = JSON.parse(e.data).k; 
                let tiempo = Math.floor(k.t / 1000); 
                let apertura = parseFloat(k.o); 
                let cierre = parseFloat(k.c);
                let comprasMercado = parseFloat(k.V); 
                let ventasMercado = parseFloat(k.v) - comprasMercado; 
                let valorDelta = comprasMercado - ventasMercado;
                
                candlestickSeries.update({ time: tiempo, open: apertura, high: parseFloat(k.h), low: parseFloat(k.l), close: cierre });
                deltaSeries.update({ time: tiempo, value: valorDelta, color: valorDelta >= 0 ? 'rgba(38, 166, 154, 0.8)' : 'rgba(239, 83, 80, 0.8)' });
                
                if (tiemposVelasActivas.length === 0 || tiemposVelasActivas[tiemposVelasActivas.length - 1] !== tiempo) {
                    tiemposVelasActivas.push(tiempo);
                }
                
                ultimoTiempoVela = tiempo; 
            };

            binanceSocket.onclose = () => {
                console.log('⚠️ Binance desconectó el gráfico. Reconectando en 3 segundos...');
                setTimeout(iniciarWebSocketVelas, 3000);
            };

            binanceSocket.onerror = (error) => {
                console.error('❌ Error en el gráfico de Binance:', error);
            };
        }

        function cargarDatos(temporalidad) {
            temporalidadActual = temporalidad; 

            fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${temporalidad}&limit=1000`)
                .then(r => r.json())
                .then(datos => {
                    let velas = []; let datosDelta = [];
                    tiemposVelasActivas = []; 

                    datos.forEach(v => {
                        let tiempo = Math.floor(v[0] / 1000); 
                        let apertura = parseFloat(v[1]); 
                        let cierre = parseFloat(v[4]);
                        let comprasMercado = parseFloat(v[9]); 
                        let ventasMercado = parseFloat(v[5]) - comprasMercado; 
                        let valorDelta = comprasMercado - ventasMercado;
                        
                        velas.push({ time: tiempo, open: apertura, high: parseFloat(v[2]), low: parseFloat(v[3]), close: cierre });
                        datosDelta.push({ time: tiempo, value: valorDelta, color: valorDelta >= 0 ? 'rgba(38, 166, 154, 0.8)' : 'rgba(239, 83, 80, 0.8)' });
                        
                        tiemposVelasActivas.push(tiempo); 
                        ultimoTiempoVela = tiempo; 
                    });
                    
                    candlestickSeries.setData(velas); 
                    deltaSeries.setData(datosDelta); 
                    
                    chartMain.timeScale().fitContent(); 
                    chartDelta.timeScale().fitContent();
                    chartOI.timeScale().fitContent();
                    
                    dibujarMarcadores(); 
                    dibujarOI(); 

                    iniciarWebSocketVelas(); 
                });
        }

        function cambiarTemporalidad(t) {
            document.querySelectorAll('.btn-tiempo').forEach(btn => btn.classList.remove('btn-activo'));
            document.getElementById(`btn-${t}`).classList.add('btn-activo'); 
            
            if(t === '1m') multiplicadorTemporalidad = 60;
            else if(t === '5m') multiplicadorTemporalidad = 300;
            else if(t === '15m') multiplicadorTemporalidad = 900;
            else if(t === '1h') multiplicadorTemporalidad = 3600;
            else if(t === '4h') multiplicadorTemporalidad = 14400;
            else if(t === '1d') multiplicadorTemporalidad = 86400;

            cargarDatos(t);
        }
        cambiarTemporalidad('1m');

        function obtenerVelaExacta(tiempoBuscado) {
            if (tiemposVelasActivas.length === 0) return null;
            for (let i = tiemposVelasActivas.length - 1; i >= 0; i--) {
                if (tiemposVelasActivas[i] <= tiempoBuscado) {
                    return tiemposVelasActivas[i];
                }
            }
            return tiemposVelasActivas[0]; 
        }

        let memoriaBallenasBD = []; 

        function pedirHistorialBallenas() {
            fetch('/api/ballenas')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    memoriaBallenasBD = datos;
                    dibujarMarcadores(); 
                })
                .catch(err => console.error("Error al pedir historial:", err));
        }

        function dibujarMarcadores() {
            const limiteBtc = parseFloat(inputFiltroGrafico.value) || 5;
            let marcadoresAgrupados = {};

            memoriaBallenasBD.forEach(trade => {
                const cantidadBtc = parseFloat(trade.cantidad);
                if (cantidadBtc >= limiteBtc) {
                    let tiempoSegundos = Math.floor(trade.tiempo_segundos);
                    let tiempoVela = obtenerVelaExacta(tiempoSegundos);

                    if (tiempoVela !== null) {
                        if (!marcadoresAgrupados[tiempoVela]) {
                            marcadoresAgrupados[tiempoVela] = { compras: 0, ventas: 0 };
                        }
                        if (trade.es_venta) {
                            marcadoresAgrupados[tiempoVela].ventas += cantidadBtc;
                        } else {
                            marcadoresAgrupados[tiempoVela].compras += cantidadBtc;
                        }
                    }
                }
            });

            let marcadores = [];
            Object.keys(marcadoresAgrupados).forEach(t => {
                let tiempo = parseInt(t);
                let datos = marcadoresAgrupados[tiempo];

                if (datos.compras > 0) {
                    marcadores.push({ time: tiempo, position: 'belowBar', color: '#26a69a', shape: 'arrowUp', text: `${datos.compras.toFixed(1)} BTC`, size: datos.compras > 15 ? 2 : 1 });
                }
                if (datos.ventas > 0) {
                    marcadores.push({ time: tiempo, position: 'aboveBar', color: '#ef5350', shape: 'arrowDown', text: `${datos.ventas.toFixed(1)} BTC`, size: datos.ventas > 15 ? 2 : 1 });
                }
            });

            marcadores.sort((a, b) => a.time - b.time);
            
            try {
                candlestickSeries.setMarkers(marcadores);
            } catch (e) {
                console.log("Error al renderizar marcadores:", e);
            }
        }

        inputFiltroGrafico.addEventListener('change', function() {
            localStorage.setItem('memoriaGrafico', this.value); 
            dibujarMarcadores(); 
        });

        setTimeout(pedirHistorialBallenas, 2000);
        setInterval(pedirHistorialBallenas, 30000);

        let memoriaOIBD = []; 

        function cargarHistorialOI() {
            fetch('/api/open-interest')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    memoriaOIBD = datos;
                    dibujarOI(); 
                })
                .catch(error => console.error("Error al cargar historial OI:", error));
        }

        function dibujarOI() {
            if (memoriaOIBD.length === 0 || tiemposVelasActivas.length === 0) return;

            let oiAgrupado = {};

            memoriaOIBD.forEach(d => {
                let tiempoOI = parseInt(d.tiempo);
                if (isNaN(tiempoOI)) return; 

                let tiempoVela = obtenerVelaExacta(tiempoOI);
                
                if (tiempoVela !== null) {
                    oiAgrupado[tiempoVela] = parseFloat(d.valor);
                }
            });

            let oiDataHistorial = [];
            Object.keys(oiAgrupado).forEach(t => {
                let valorFinal = oiAgrupado[t];
                if (!isNaN(valorFinal)) {
                    oiDataHistorial.push({ time: parseInt(t), value: valorFinal });
                }
            });
            
            oiDataHistorial.sort((a, b) => a.time - b.time);
            
            if (oiDataHistorial.length > 0) {
                try { oiSeries.setData(oiDataHistorial); } 
                catch (error) { console.log("Error interno al dibujar Open Interest:", error); }
            }
        }

        function actualizarOpenInterestEnVivo() {
            fetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=BTCUSDT')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    if (ultimoTiempoVela) {
                        let contratosAbiertos = parseFloat(datos.openInterest);
                        oiSeries.update({ time: ultimoTiempoVela, value: contratosAbiertos });
                    }
                })
                .catch(error => console.log("Error al traer Open Interest en vivo:", error));
        }
        
        setTimeout(() => {
            cargarHistorialOI();
            setTimeout(() => {
                actualizarOpenInterestEnVivo();
                setInterval(actualizarOpenInterestEnVivo, 3000);
            }, 3000);
        }, 1000);

        let orderBookLocal = { asks: {}, bids: {} };
        const TAMAÑO_GRUPO = 50; 
        let seriesDeMuros = []; 

        fetch('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=1000')
            .then(r => r.json())
            .then(datos => {
                datos.asks.forEach(a => orderBookLocal.asks[parseFloat(a[0])] = parseFloat(a[1]));
                datos.bids.forEach(b => orderBookLocal.bids[parseFloat(b[0])] = parseFloat(b[1]));
                iniciarActualizacionMurosEnVivo();
            });

        function iniciarActualizacionMurosEnVivo() {
            const depthSocket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@depth@1000ms');
            depthSocket.onmessage = function(e) {
                const cambios = JSON.parse(e.data);
                cambios.a.forEach(ask => {
                    let precio = parseFloat(ask[0]); let cantidad = parseFloat(ask[1]);
                    if (cantidad === 0) delete orderBookLocal.asks[precio];
                    else orderBookLocal.asks[precio] = cantidad;
                });
                cambios.b.forEach(bid => {
                    let precio = parseFloat(bid[0]); let cantidad = parseFloat(bid[1]);
                    if (cantidad === 0) delete orderBookLocal.bids[precio];
                    else orderBookLocal.bids[precio] = cantidad;
                });
            };
        }

        function agruparDiccionario(diccionario) {
            let agrupado = {};
            for (let precioStr in diccionario) {
                let precio = parseFloat(precioStr); let cantidad = diccionario[precioStr];
                let precioAgrupado = Math.floor(precio / TAMAÑO_GRUPO) * TAMAÑO_GRUPO;
                if (!agrupado[precioAgrupado]) agrupado[precioAgrupado] = 0;
                agrupado[precioAgrupado] += cantidad;
            }
            return Object.keys(agrupado).map(p => [parseFloat(p), agrupado[p]]);
        }

        function dibujarMuros() {
            let preciosVentas = Object.keys(orderBookLocal.asks).map(parseFloat).sort((a,b) => a - b);
            let preciosCompras = Object.keys(orderBookLocal.bids).map(parseFloat).sort((a,b) => b - a);
            if (preciosVentas.length === 0 || preciosCompras.length === 0) return; 

            let precioActual = (preciosVentas[0] + preciosCompras[0]) / 2;
            let porcentajeInput = parseFloat(document.getElementById('input-rango').value);
            if (isNaN(porcentajeInput) || porcentajeInput <= 0) porcentajeInput = 2; 
            
            let factorArriba = 1 + (porcentajeInput / 100); let factorAbajo = 1 - (porcentajeInput / 100);  

            let ventasAgrupadas = agruparDiccionario(orderBookLocal.asks);
            let comprasAgrupadas = agruparDiccionario(orderBookLocal.bids);

            let ventasEnRango = ventasAgrupadas.filter(v => v[0] <= precioActual * factorArriba).sort((a, b) => b[1] - a[1]);
            let comprasEnRango = comprasAgrupadas.filter(c => c[0] >= precioActual * factorAbajo).sort((a, b) => b[1] - a[1]);
            
            let top3Ventas = ventasEnRango.slice(0, 3); let top3Compras = comprasEnRango.slice(0, 3);

            document.getElementById('top-ventas').innerHTML = top3Ventas.map(v => `<div class="muro-item"><span class="muro-precio" style="color:#ef5350;">$${v[0].toFixed(2)}</span> <span class="muro-volumen">${v[1].toFixed(2)} BTC</span></div>`).join('');
            document.getElementById('top-compras').innerHTML = top3Compras.map(c => `<div class="muro-item"><span class="muro-precio" style="color:#26a69a;">$${c[0].toFixed(2)}</span> <span class="muro-volumen">${c[1].toFixed(2)} BTC</span></div>`).join('');

            seriesDeMuros.forEach(serie => chartMain.removeSeries(serie)); 
            seriesDeMuros = []; 

            if (!ultimoTiempoVela) return;

            let tiempoFuturo = ultimoTiempoVela + (multiplicadorTemporalidad * 500);

            top3Ventas.forEach(v => {
                let serieMuro = chartMain.addLineSeries({
                    color: '#ef5350', 
                    lineWidth: 2, 
                    lineStyle: LightweightCharts.LineStyle.Dashed, 
                    lastValueVisible: true, 
                    priceLineVisible: false, 
                    crosshairMarkerVisible: false,
                    title: `RES ${v[1].toFixed(0)} BTC`
                });
                serieMuro.setData([
                    { time: ultimoTiempoVela, value: v[0] }, 
                    { time: tiempoFuturo, value: v[0] }      
                ]);
                seriesDeMuros.push(serieMuro);
            });

            top3Compras.forEach(c => {
                let serieMuro = chartMain.addLineSeries({
                    color: '#26a69a', 
                    lineWidth: 2, 
                    lineStyle: LightweightCharts.LineStyle.Dashed, 
                    lastValueVisible: true, 
                    priceLineVisible: false, 
                    crosshairMarkerVisible: false,
                    title: `SOP ${c[1].toFixed(0)} BTC`
                });
                serieMuro.setData([
                    { time: ultimoTiempoVela, value: c[0] }, 
                    { time: tiempoFuturo, value: c[0] }      
                ]);
                seriesDeMuros.push(serieMuro);
            });
        }

        setInterval(dibujarMuros, 2000);
        document.getElementById('input-rango').addEventListener('change', dibujarMuros);

        fetch('/api/filtro-bd')
            .then(res => res.json())
            .then(data => {
                document.getElementById('filtro-bd').value = data.umbral;
            })
            .catch(err => console.log('Error al leer filtro de BD:', err));

        document.getElementById('filtro-bd').addEventListener('change', function() {
            const nuevoUmbral = parseFloat(this.value);
            fetch('/api/filtro-bd', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ umbral: nuevoUmbral })
            })
            .then(res => res.json())
            .then(data => console.log('El servidor confirmó el nuevo límite de BD:', data.umbral))
            .catch(err => console.log('Error al actualizar filtro en servidor:', err));
        });

        const tapeSocket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@aggTrade');
        let ultimosTrades = []; 

        tapeSocket.onmessage = function(evento) {
            const data = JSON.parse(evento.data); 
            const cantidad = parseFloat(data.q); 
            const precio = parseFloat(data.p); 
            const agresorFueVendedor = data.m; 
            
            const limiteCintaVisual = parseFloat(inputFiltroCinta.value) || 1.0;

            if (cantidad >= limiteCintaVisual) {
                ultimosTrades.unshift({ precio: precio, cantidad: cantidad, esVenta: agresorFueVendedor });
                if (ultimosTrades.length > 5) ultimosTrades.pop(); 
                let htmlCinta = '';
                ultimosTrades.forEach((trade, indice) => {
                    let color = trade.esVenta ? '#ef5350' : '#26a69a'; let claseFlash = indice === 0 ? 'flash-trade' : '';
                    htmlCinta += `<div class="muro-item ${claseFlash}"><span class="muro-precio" style="color:${color};">$${trade.precio.toFixed(2)}</span><span class="muro-volumen">${trade.cantidad.toFixed(2)} BTC</span></div>`;
                });
                document.getElementById('whale-tape').innerHTML = htmlCinta;
            }
        };

    </script>
</body>
</html>
