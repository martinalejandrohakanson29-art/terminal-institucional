<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Institucional BTC/USDT Nivel Dios</title>
    
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; background-color: #131722; color: white; font-family: Arial, sans-serif; overflow: hidden; width: 100vw; height: 100vh; }
        #header { padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; background-color: #1e222d; border-bottom: 1px solid #2B2B43; height: 60px; }
        h2 { margin: 0; font-size: 1.2rem; }
        
        .botonera { display: flex; gap: 5px; align-items: center; }
        .btn-tiempo { background-color: #2B2B43; color: #d1d4dc; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        .btn-tiempo:hover { background-color: #3f3f5a; }
        .btn-activo { background-color: #2962FF; color: white; }

        #main-content { display: flex; width: 100%; height: calc(100vh - 60px); }
        #chart-container { flex-grow: 1; position: relative; overflow: hidden; } 

        #orderbook-container {
            width: 320px; min-width: 320px; flex-shrink: 0; background-color: #1e222d; border-left: 1px solid #2B2B43; display: flex; flex-direction: column; font-size: 13px; overflow-y: auto;
        }
        
        .ob-titulo { text-align: center; padding: 12px 10px 5px; font-weight: bold; font-size: 15px; background-color: #131722; color: #d1d4dc;}
        .ob-subtitulo { text-align: center; font-size: 11px; color: #848e9c; padding-bottom: 10px; border-bottom: 1px solid #2B2B43; background-color: #131722; display: flex; justify-content: center; align-items: center; gap: 5px;}
        
        .input-rango { background-color: #2B2B43; color: #FFD700; border: 1px solid #3f3f5a; border-radius: 4px; width: 45px; text-align: center; font-weight: bold; font-size: 11px; padding: 2px; outline: none; }
        
        .seccion-panel { padding: 10px; border-bottom: 1px solid #2B2B43; }
        .titulo-rojo { color: #ef5350; font-weight: bold; margin-bottom: 8px; text-align: center; }
        .titulo-verde { color: #26a69a; font-weight: bold; margin-bottom: 8px; text-align: center; }
        
        .muro-item { display: flex; justify-content: space-between; background-color: #131722; padding: 6px 10px; margin-bottom: 4px; border-radius: 4px; font-family: monospace; align-items: center; }
        .muro-precio { font-weight: bold; font-size: 13px; }
        .muro-volumen { color: #d1d4dc; font-size: 13px; }

        @keyframes destello { 0% { background-color: rgba(255, 215, 0, 0.5); } 100% { background-color: #131722; } }
        .flash-trade { animation: destello 1s ease-out; }
    </style>
</head>
<body>

    <div id="header">
        <h2>Terminal Institucional BTC/USDT</h2>
        
        <div class="botonera" style="margin-right: auto; margin-left: 20px;">
            <span style="font-size: 12px; color: #848e9c; margin-right: 5px;">Filtrar marcadores Gráfico (BTC): ></span>
            <input type="number" id="filtro-grafico" class="input-rango" value="5" min="1" step="1">
        </div>

        <div class="botonera">
            <button class="btn-tiempo btn-activo" id="btn-1m" onclick="cambiarTemporalidad('1m')">1m</button>
            <button class="btn-tiempo" id="btn-5m" onclick="cambiarTemporalidad('5m')">5m</button>
            <button class="btn-tiempo" id="btn-15m" onclick="cambiarTemporalidad('15m')">15m</button>
            <button class="btn-tiempo" id="btn-1h" onclick="cambiarTemporalidad('1h')">1H</button>
            <button class="btn-tiempo" id="btn-4h" onclick="cambiarTemporalidad('4h')">4H</button>
            <button class="btn-tiempo" id="btn-1d" onclick="cambiarTemporalidad('1d')">1D</button>
        </div>
    </div>
    
    <div id="main-content">
        <div id="chart-container"></div>
        <div id="orderbook-container">
            <div class="ob-titulo">TOP 3 MUROS (INTENCIÓN)</div>
            <div class="ob-subtitulo">Rango: <input type="number" id="input-rango" class="input-rango" value="2" min="1" max="10">% | Agrupado: $50</div>
            
            <div class="seccion-panel">
                <div class="titulo-rojo">RESISTENCIAS (Ventas)</div>
                <div id="top-ventas">Cargando radar...</div>
            </div>
            
            <div class="seccion-panel">
                <div class="titulo-verde">SOPORTES (Compras)</div>
                <div id="top-compras">Cargando radar...</div>
            </div>

            <div class="seccion-panel" style="border-bottom: none;">
                <div class="ob-titulo" style="padding-top: 5px;">CINTA EN VIVO (ACCIÓN)</div>
                
                <div class="ob-subtitulo" style="flex-direction: column; gap: 8px;">
                    <div>Ver en Cinta: > <input type="number" id="filtro-cinta" class="input-rango" value="1" min="0.1" step="0.5"> BTC</div>
                    <div>Guardar BD: > <input type="number" id="filtro-bd" class="input-rango" value="1" min="0.1" step="0.5" title="Actualiza el servidor"> BTC</div>
                </div>

                <div id="whale-tape">Esperando órdenes gigantes...</div>
            </div>
        </div>
    </div>

    <script>
        // --- RECUPERAR MEMORIA DEL NAVEGADOR AL CARGAR ---
        const inputFiltroGrafico = document.getElementById('filtro-grafico');
        const inputFiltroCinta = document.getElementById('filtro-cinta');

        if (localStorage.getItem('memoriaGrafico')) {
            inputFiltroGrafico.value = localStorage.getItem('memoriaGrafico');
        }
        if (localStorage.getItem('memoriaCinta')) {
            inputFiltroCinta.value = localStorage.getItem('memoriaCinta');
        }

        inputFiltroCinta.addEventListener('change', function() {
            localStorage.setItem('memoriaCinta', this.value);
        });

        // --- 1. GRÁFICO (Velas, Delta, Open Interest) ---
        const container = document.getElementById('chart-container');
        const chartOptions = { width: container.clientWidth, height: container.clientHeight, layout: { textColor: '#d1d4dc', background: { type: 'solid', color: '#131722' } }, grid: { vertLines: { color: '#2B2B43' }, horzLines: { color: '#2B2B43' } }, crosshair: { mode: LightweightCharts.CrosshairMode.Normal }, rightPriceScale: { borderColor: '#2B2B43' }, timeScale: { borderColor: '#2B2B43', timeVisible: true, secondsVisible: false }, };
        const chart = LightweightCharts.createChart(container, chartOptions);
        
        const candlestickSeries = chart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
        const deltaSeries = chart.addHistogramSeries({ base: 0, priceScaleId: 'deltaScale' });
        chart.priceScale('deltaScale').applyOptions({ scaleMargins: { top: 0.65, bottom: 0.2 } });
        const oiSeries = chart.addAreaSeries({ lineColor: '#FFD700', topColor: 'rgba(255, 215, 0, 0.3)', bottomColor: 'rgba(255, 215, 0, 0.0)', lineWidth: 2, priceScaleId: 'oiScale', title: 'Open Int.' });
        chart.priceScale('oiScale').applyOptions({ scaleMargins: { top: 0.85, bottom: 0 } });

        window.addEventListener('resize', () => { chart.resize(container.clientWidth, container.clientHeight); });

        let binanceSocket = null; 
        let ultimoTiempoVela = null; 
        
        // Variable mágica para alinear el tiempo de las ballenas
        let intervaloGlobalSegundos = 60;

        function cargarDatos(temporalidad) {
            if (binanceSocket !== null) binanceSocket.close();
            fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${temporalidad}&limit=1000`)
                .then(r => r.json())
                .then(datos => {
                    let velas = []; let datosDelta = [];
                    datos.forEach(v => {
                        let tiempo = Math.floor(v[0] / 1000); let apertura = parseFloat(v[1]); let cierre = parseFloat(v[4]);
                        let comprasMercado = parseFloat(v[9]); let ventasMercado = parseFloat(v[5]) - comprasMercado; let valorDelta = comprasMercado - ventasMercado;
                        velas.push({ time: tiempo, open: apertura, high: parseFloat(v[2]), low: parseFloat(v[3]), close: cierre });
                        datosDelta.push({ time: tiempo, value: valorDelta, color: valorDelta >= 0 ? 'rgba(38, 166, 154, 0.8)' : 'rgba(239, 83, 80, 0.8)' });
                        ultimoTiempoVela = tiempo; 
                    });
                    candlestickSeries.setData(velas); deltaSeries.setData(datosDelta); chart.timeScale().fitContent(); 

                    binanceSocket = new WebSocket(`wss://stream.binance.com:9443/ws/btcusdt@kline_${temporalidad}`);
                    binanceSocket.onmessage = function (e) {
                        const k = JSON.parse(e.data).k; let tiempo = Math.floor(k.t / 1000); let apertura = parseFloat(k.o); let cierre = parseFloat(k.c);
                        let comprasMercado = parseFloat(k.V); let ventasMercado = parseFloat(k.v) - comprasMercado; let valorDelta = comprasMercado - ventasMercado;
                        candlestickSeries.update({ time: tiempo, open: apertura, high: parseFloat(k.h), low: parseFloat(k.l), close: cierre });
                        deltaSeries.update({ time: tiempo, value: valorDelta, color: valorDelta >= 0 ? 'rgba(38, 166, 154, 0.8)' : 'rgba(239, 83, 80, 0.8)' });
                        ultimoTiempoVela = tiempo; 
                    };
                });
        }

        function cambiarTemporalidad(t) {
            document.querySelectorAll('.btn-tiempo').forEach(btn => btn.classList.remove('btn-activo'));
            document.getElementById(`btn-${t}`).classList.add('btn-activo'); 
            
            // Calculamos cuántos segundos tiene la temporalidad actual
            if (t === '1m') intervaloGlobalSegundos = 60;
            else if (t === '5m') intervaloGlobalSegundos = 300;
            else if (t === '15m') intervaloGlobalSegundos = 900;
            else if (t === '1h') intervaloGlobalSegundos = 3600;
            else if (t === '4h') intervaloGlobalSegundos = 14400;
            else if (t === '1d') intervaloGlobalSegundos = 86400;

            cargarDatos(t);
        }
        cambiarTemporalidad('1m');

        // --- DIBUJADO DE BALLENAS EN EL GRÁFICO ---
        let memoriaBallenasBD = []; 

        function pedirHistorialBallenas() {
            fetch('/api/ballenas')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    memoriaBallenasBD = datos;
                    dibujarMarcadores(); 
                })
                .catch(err => console.error("Error al pedir historial:", err));
        }

        function dibujarMarcadores() {
            const limiteBtc = parseFloat(inputFiltroGrafico.value) || 5;
            let marcadoresAgrupados = {};

            // Agrupamos y sumamos las ballenas por vela
            memoriaBallenasBD.forEach(trade => {
                const cantidadBtc = parseFloat(trade.cantidad);
                if (cantidadBtc >= limiteBtc) {
                    let tiempoSegundos = Math.floor(trade.tiempo_segundos);
                    
                    // Alineación perfecta: forzamos que el tiempo coincida con la apertura de la vela
                    let tiempoVela = Math.floor(tiempoSegundos / intervaloGlobalSegundos) * intervaloGlobalSegundos;

                    if (!marcadoresAgrupados[tiempoVela]) {
                        marcadoresAgrupados[tiempoVela] = { compras: 0, ventas: 0 };
                    }

                    if (trade.es_venta) {
                        marcadoresAgrupados[tiempoVela].ventas += cantidadBtc;
                    } else {
                        marcadoresAgrupados[tiempoVela].compras += cantidadBtc;
                    }
                }
            });

            let marcadores = [];

            // Convertimos los grupos al formato que necesita la librería
            Object.keys(marcadoresAgrupados).forEach(t => {
                let tiempo = parseInt(t);
                let datos = marcadoresAgrupados[tiempo];

                if (datos.compras > 0) {
                    marcadores.push({
                        time: tiempo,
                        position: 'belowBar',
                        color: '#26a69a',
                        shape: 'arrowUp',
                        text: `${datos.compras.toFixed(1)} BTC`,
                        size: datos.compras > 15 ? 2 : 1
                    });
                }
                
                if (datos.ventas > 0) {
                    marcadores.push({
                        time: tiempo,
                        position: 'aboveBar',
                        color: '#ef5350',
                        shape: 'arrowDown',
                        text: `${datos.ventas.toFixed(1)} BTC`,
                        size: datos.ventas > 15 ? 2 : 1
                    });
                }
            });

            // Requisito estricto de la librería: ordenar por tiempo de viejo a nuevo
            marcadores.sort((a, b) => a.time - b.time);
            
            try {
                candlestickSeries.setMarkers(marcadores);
            } catch (e) {
                console.log("Error al renderizar marcadores:", e);
            }
        }

        inputFiltroGrafico.addEventListener('change', function() {
            localStorage.setItem('memoriaGrafico', this.value); 
            dibujarMarcadores(); 
        });

        setTimeout(pedirHistorialBallenas, 2000);
        setInterval(pedirHistorialBallenas, 30000);

        // --- 2. SISTEMA PROFESIONAL DE MUROS LOCALES ---
        let orderBookLocal = { asks: {}, bids: {} };
        const TAMAÑO_GRUPO = 50; 
        let lineasDibujadas = []; 

        fetch('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=1000')
            .then(r => r.json())
            .then(datos => {
                datos.asks.forEach(a => orderBookLocal.asks[parseFloat(a[0])] = parseFloat(a[1]));
                datos.bids.forEach(b => orderBookLocal.bids[parseFloat(b[0])] = parseFloat(b[1]));
                iniciarActualizacionMurosEnVivo();
            });

        function iniciarActualizacionMurosEnVivo() {
            const depthSocket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@depth@1000ms');
            depthSocket.onmessage = function(e) {
                const cambios = JSON.parse(e.data);
                cambios.a.forEach(ask => {
                    let precio = parseFloat(ask[0]); let cantidad = parseFloat(ask[1]);
                    if (cantidad === 0) delete orderBookLocal.asks[precio];
                    else orderBookLocal.asks[precio] = cantidad;
                });
                cambios.b.forEach(bid => {
                    let precio = parseFloat(bid[0]); let cantidad = parseFloat(bid[1]);
                    if (cantidad === 0) delete orderBookLocal.bids[precio];
                    else orderBookLocal.bids[precio] = cantidad;
                });
            };
        }

        function agruparDiccionario(diccionario) {
            let agrupado = {};
            for (let precioStr in diccionario) {
                let precio = parseFloat(precioStr); let cantidad = diccionario[precioStr];
                let precioAgrupado = Math.floor(precio / TAMAÑO_GRUPO) * TAMAÑO_GRUPO;
                if (!agrupado[precioAgrupado]) agrupado[precioAgrupado] = 0;
                agrupado[precioAgrupado] += cantidad;
            }
            return Object.keys(agrupado).map(p => [parseFloat(p), agrupado[p]]);
        }

        function dibujarMuros() {
            let preciosVentas = Object.keys(orderBookLocal.asks).map(parseFloat).sort((a,b) => a - b);
            let preciosCompras = Object.keys(orderBookLocal.bids).map(parseFloat).sort((a,b) => b - a);
            if (preciosVentas.length === 0 || preciosCompras.length === 0) return; 

            let precioActual = (preciosVentas[0] + preciosCompras[0]) / 2;
            let porcentajeInput = parseFloat(document.getElementById('input-rango').value);
            if (isNaN(porcentajeInput) || porcentajeInput <= 0) porcentajeInput = 2; 
            
            let factorArriba = 1 + (porcentajeInput / 100); let factorAbajo = 1 - (porcentajeInput / 100);  

            let ventasAgrupadas = agruparDiccionario(orderBookLocal.asks);
            let comprasAgrupadas = agruparDiccionario(orderBookLocal.bids);

            let ventasEnRango = ventasAgrupadas.filter(v => v[0] <= precioActual * factorArriba).sort((a, b) => b[1] - a[1]);
            let comprasEnRango = comprasAgrupadas.filter(c => c[0] >= precioActual * factorAbajo).sort((a, b) => b[1] - a[1]);
            
            let top3Ventas = ventasEnRango.slice(0, 3); let top3Compras = comprasEnRango.slice(0, 3);

            document.getElementById('top-ventas').innerHTML = top3Ventas.map(v => `<div class="muro-item"><span class="muro-precio" style="color:#ef5350;">$${v[0].toFixed(2)}</span> <span class="muro-volumen">${v[1].toFixed(2)} BTC</span></div>`).join('');
            document.getElementById('top-compras').innerHTML = top3Compras.map(c => `<div class="muro-item"><span class="muro-precio" style="color:#26a69a;">$${c[0].toFixed(2)}</span> <span class="muro-volumen">${c[1].toFixed(2)} BTC</span></div>`).join('');

            lineasDibujadas.forEach(linea => candlestickSeries.removePriceLine(linea)); lineasDibujadas = []; 
            top3Ventas.forEach(v => lineasDibujadas.push(candlestickSeries.createPriceLine({ price: v[0], color: '#ef5350', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: `RES ${v[1].toFixed(0)} BTC` })));
            top3Compras.forEach(c => lineasDibujadas.push(candlestickSeries.createPriceLine({ price: c[0], color: '#26a69a', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: `SOP ${c[1].toFixed(0)} BTC` })));
        }

        setInterval(dibujarMuros, 2000);
        document.getElementById('input-rango').addEventListener('change', dibujarMuros);

        // --- 3. CINTA DE BALLENAS (aggTrade) y SINCRONIZACIÓN CON BD ---
        fetch('/api/filtro-bd')
            .then(res => res.json())
            .then(data => {
                document.getElementById('filtro-bd').value = data.umbral;
            })
            .catch(err => console.log('Error al leer filtro de BD:', err));

        document.getElementById('filtro-bd').addEventListener('change', function() {
            const nuevoUmbral = parseFloat(this.value);
            fetch('/api/filtro-bd', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ umbral: nuevoUmbral })
            })
            .then(res => res.json())
            .then(data => console.log('El servidor confirmó el nuevo límite de BD:', data.umbral))
            .catch(err => console.log('Error al actualizar filtro en servidor:', err));
        });

        const tapeSocket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@aggTrade');
        let ultimosTrades = []; 

        tapeSocket.onmessage = function(evento) {
            const data = JSON.parse(evento.data); 
            const cantidad = parseFloat(data.q); 
            const precio = parseFloat(data.p); 
            const agresorFueVendedor = data.m; 
            
            const limiteCintaVisual = parseFloat(inputFiltroCinta.value) || 1.0;

            if (cantidad >= limiteCintaVisual) {
                ultimosTrades.unshift({ precio: precio, cantidad: cantidad, esVenta: agresorFueVendedor });
                if (ultimosTrades.length > 5) ultimosTrades.pop(); 
                let htmlCinta = '';
                ultimosTrades.forEach((trade, indice) => {
                    let color = trade.esVenta ? '#ef5350' : '#26a69a'; let claseFlash = indice === 0 ? 'flash-trade' : '';
                    htmlCinta += `<div class="muro-item ${claseFlash}"><span class="muro-precio" style="color:${color};">$${trade.precio.toFixed(2)}</span><span class="muro-volumen">${trade.cantidad.toFixed(2)} BTC</span></div>`;
                });
                document.getElementById('whale-tape').innerHTML = htmlCinta;
            }
        };

        // --- 4. INTERÉS ABIERTO (HISTÓRICO + EN VIVO) ---
        function cargarHistorialOI() {
            fetch('/api/open-interest')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    let oiDataHistorial = [];
                    datos.forEach(d => {
                        oiDataHistorial.push({ time: parseInt(d.tiempo), value: parseFloat(d.valor) });
                    });
                    
                    oiDataHistorial.sort((a, b) => a.time - b.time);
                    
                    if(oiDataHistorial.length > 0) {
                        oiSeries.setData(oiDataHistorial);
                    }
                    
                    actualizarOpenInterestEnVivo();
                    setInterval(actualizarOpenInterestEnVivo, 3000);
                })
                .catch(error => {
                    console.error("Error al cargar historial OI:", error);
                    actualizarOpenInterestEnVivo();
                    setInterval(actualizarOpenInterestEnVivo, 3000);
                });
        }

        function actualizarOpenInterestEnVivo() {
            fetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=BTCUSDT')
                .then(respuesta => respuesta.json())
                .then(datos => {
                    if (ultimoTiempoVela) {
                        let contratosAbiertos = parseFloat(datos.openInterest);
                        oiSeries.update({ time: ultimoTiempoVela, value: contratosAbiertos });
                    }
                })
                .catch(error => console.log("Error al traer Open Interest en vivo:", error));
        }
        
        setTimeout(cargarHistorialOI, 1000);

    </script>
</body>
</html>
